{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to the Jenkins shared library project Welcome to the Jenkins shared library project Purpose Quickstart About quality Useful links Purpose providing a reference example project for your own Jenkins shared library project demonstrating usage of the basic toolset: Groovy, Gradle, Jacoco, Codenarc, mkdocs, ... providing Jenkinsfile (declarative pipeline) as well as .travis.yml automatically running this project on Travis CI and publishing coverage on coveralls.io providing detailed documentation Quickstart Using the Gradle wrapper the configured Gradle version will be automatically downloaded and used. The basic requirements can be easily seen in the file Dockerfile serving as description for a Docker build image. ./gradlew About quality You should have a verified code style. The tool Codenarc provides you for Groovy what Checkstyle does for Java. The build does fail when any source code does not match the defined rules. It runs automatically with ./gradlew . Code coverage check is configured and 100% code coverage (line) is expected ! If you add new functionality without a test the build will fail. It also runs automatically with ./gradlew . Provide reasonable documentation . Any documentation like this one is for you as well as for others. Please consider source code documentation as well as markdown based documentation to help to understand things. Useful links https://jenkins.io/doc/book/pipeline/syntax/ https://jenkins.io/doc/pipeline/steps/pipeline-utility-steps/ https://jenkins.io/doc/book/pipeline/syntax/#declarative-pipeline https://jenkins.io/doc/book/pipeline/docker/ https://jenkins.io/doc/pipeline/steps/ https://gradle.org/ https://docs.gradle.org/current/userguide/jacoco_plugin.html https://gradle-pitest-plugin.solidsoft.info/ http://pitest.org/ http://codenarc.sourceforge.net/ https://www.mkdocs.org/","title":"Home"},{"location":"documentation/","text":"How to organize Documenation Markdown Markdown seems a good choice when writing documentation with just a small set of formatting capabilities reducing the documentation to what is really needed: titles sections bold and italic emphasizing code blocks tables links embedded images Mkdocs There are many good tools but I feel very comfortable with mkdocs because of following reasons: Easy to install ( sudo pip install mkdocs ) Easy to configure (Small and simple mkdocs.yml in the root of your repository) Easy to verify of the final result ( mkdocs serve ) Each change of the configured markdown files updates automatically your browser Easy to publish to github pages ( mkdocs gh-deploy ) In my case: simply my user and password for my Github account Please note: There's also a plugin for gradle but it looks to me that the excepted folder struture is different and I have not yet found a way to use the exising folder structure.","title":"How to organize Documenation"},{"location":"documentation/#how-to-organize-documenation","text":"","title":"How to organize Documenation"},{"location":"documentation/#markdown","text":"Markdown seems a good choice when writing documentation with just a small set of formatting capabilities reducing the documentation to what is really needed: titles sections bold and italic emphasizing code blocks tables links embedded images","title":"Markdown"},{"location":"documentation/#mkdocs","text":"There are many good tools but I feel very comfortable with mkdocs because of following reasons: Easy to install ( sudo pip install mkdocs ) Easy to configure (Small and simple mkdocs.yml in the root of your repository) Easy to verify of the final result ( mkdocs serve ) Each change of the configured markdown files updates automatically your browser Easy to publish to github pages ( mkdocs gh-deploy ) In my case: simply my user and password for my Github account Please note: There's also a plugin for gradle but it looks to me that the excepted folder struture is different and I have not yet found a way to use the exising folder structure.","title":"Mkdocs"},{"location":"gradle/","text":"How to organize Gradle How to organize Gradle Why Gradle? The Gradle Wrapper Current Gradle version Adding a wrapper Upgrading the Gradle version Basic Setup Best Practises Why Gradle? Gradle is very comfortable task manager to build your project. You can define the required tasks with a short amount of code . The Gradle Wrapper The gradle wrapper helps you to install the Gradle version you need. Current Gradle version ./gradlew --version Adding a wrapper gradle wrapper Upgrading the Gradle version Define the version of Gradle you would like to have: ./gradlew wrapper --gradle-version 4.9 You can verify it like following: $ cat gradle/wrapper/gradle-wrapper.properties distributionBase=GRADLE_USER_HOME distributionPath=wrapper/dists distributionUrl=https\\://services.gradle.org/distributions/gradle-4.9-bin.zip zipStoreBase=GRADLE_USER_HOME zipStorePath=wrapper/dists Basic Setup Of course it requires apply plugin: 'groovy' because the shared library (Jenkins) depends on it. The source sets have to be changed because the Jenkins guys do not use the standard folder structure as proposed by Maven/Gradle. The name of the languages (here: groovy) has been removed from the paths. You are not advised to use vars in the source sets because you cannot test the code and you code coverage would essentially decrease. Jacoco is used as official documented. Code coverage should be above 85% (line coverage 100%). Adding new functionality without adding sufficient tests should fail the build. Codenarc is the static code analyser for Groovy. Most rules are used and located under config/codenarc/codenarc.rules . Every rule that is not correct applied will fail the build. Coveralls (a great service for visualizing code coverage results) is useful if you run your Github project with integrations like Travis CI - In both cases you have to enable the repository there before you can use it; in my case login with my Github Account to Travis CI as well as to COVERALLS ; it's mainly a button to toggle the wanted repository on/off. Best Practises When one of your tests is failing Gradle usually prints the path to the XML file instead of showing the problem. Therefor you can do following: gradle test -i ; the -i forces to print all to stdout and that way you can easily scroll back the terminal to the printed callstack. Continous testing can be done with gradle test -it . Gradle detects changes in files when you save them and reruns the tasks (here: all tests). You also can run individual tests with a filter: gradle test -it --tests GradleTest","title":"How to organize Gradle"},{"location":"jobdslcode/","text":"Job DSL code support Job DSL code support Purpose Job definition Example with JSON Example with YAML Purpose Job DSL is great Jenkins pluging offering you an API for creating and/or updating of Jenkins jobs and views. This library adds now functionality to read a job description via Map (in Memory), a JSON file or a YAML file generating Job DSL code. Job definition Independent whether you use a Map in memory, a JSON file or a yaml file the job definition for creating a new job is following: field meaning comment name name of the job an existing job with will be update if it is of same type description job description also may contain HTML; rendered when configured in Jenkins type type of job supported: MULTIBRANCH_PIPELINE (default) or PIPELINE source source url git is supported only (ssh or https variant of url to clone) credentialsId Id of credentials optional ; Jenkins credentials store for SSH credentials script Jenkinsfile path path and filename of Jenkinsfile (default: Jenkinsfile) history number of builds pipeline only ; how many old builds to keep (default: 30) Example with JSON @Library('jenkins-shared-library@master') import groovy.json.JsonOutput pipeline { agent any stages { stage('Prepare') { steps { script { final DATA = readJSON(text:groovy.json.JsonOutput.toJson([ type:'MULTIBRANCH_PIPELINE', name:'jenkins-shared-library-demo', description:'a Jenkins shared library', source:'https://github.com/Nachtfeuer/jenkins-shared-library.git', script:'Jenkinsfile', ])) writeJSON(file:'demo.json', json:DATA) } } } stage('Job DSL') { steps { script { jobDsl(scriptText:jobDslCode.fromJson('demo.json)) } } } } } Example with YAML @Library('jenkins-shared-library@master') pipeline { agent any stages { stage('Prepare') { steps { script { final DATA = [ type:'MULTIBRANCH_PIPELINE', name:'jenkins-shared-library-demo', description:'a Jenkins shared library', source:'https://github.com/Nachtfeuer/jenkins-shared-library.git', script:'Jenkinsfile', ] writeYaml(file:'demo.yaml', data:DATA) } } } stage('Job DSL') { steps { script { jobDsl(scriptText:jobDslCode.fromYaml('demo.yaml')) } } } } }","title":"Job DSL code support"},{"location":"virtualenv/","text":"Python virtual environments Python virtual environments Most simple usage Passing requirements Defining another virtual environment folder Error handling Most simple usage virtualenv { sh(script:'python -m install spline') sh(script:'python -m spline.application --help') } Passing requirements virtualenv(['spline', 'requests==2.12.4']) { sh(script:'python -m spline.application --help') } Defining another virtual environment folder virtualenv(['spline', 'requests==2.12.4'], 'another-venv') { sh(script:'python -m spline.application --help') } Error handling When inside a virtual environment an exception is thrown: the result of such a block is null . the pipeline state (currentBuild.result) will be set to 'FAILURE'. the virtual environment will be removed independent of that issue.","title":"Python virtual environments"},{"location":"xfind/","text":"Find DSL How to use? def files = xfind.files('.', '*.json') The command is equivalent to find . -type f -name \"*.json\" . Please note : - In a declarative pipeline you have to place it in a script { ... } block.","title":"Find DSL"},{"location":"xfind/#find-dsl","text":"","title":"Find DSL"},{"location":"xfind/#how-to-use","text":"def files = xfind.files('.', '*.json') The command is equivalent to find . -type f -name \"*.json\" . Please note : - In a declarative pipeline you have to place it in a script { ... } block.","title":"How to use?"},{"location":"xgit/","text":"Git DSL Usage echo('Git short commit: ' + xgit.shortCommit) echo('Git url: ' + xgit.url) echo('Git author name: ' + xgit.authorName) echo('Git author mail: ' + xgit.authorMail) Please note : - In a declarative pipeline you have to place it in a script { ... } block.","title":"Git DSL"},{"location":"xgit/#git-dsl","text":"","title":"Git DSL"},{"location":"xgit/#usage","text":"echo('Git short commit: ' + xgit.shortCommit) echo('Git url: ' + xgit.url) echo('Git author name: ' + xgit.authorName) echo('Git author mail: ' + xgit.authorMail) Please note : - In a declarative pipeline you have to place it in a script { ... } block.","title":"Usage"},{"location":"xgradle/","text":"Own Gradle DSL Purpose builder concept (chaining of tasks) standardization (junit, jacoco, ...) Build The xgradle DSL does use internally a Gradle class chaining the tasks clean and check : xgradle.build() Please note : In a declarative pipeline you have to place it in a script { ... } block. Publish Publishing of build results (junit, jacoco, HTML coverage and Pit test coverage): xgradle.publish() Please note : - In a declarative pipeline you have to place it in a script { ... } block. - The reports are published only when the path do exist; for coverage build/reports/coverage and for pit test build/reports/pitest are the expected paths. Using Jacoco you can configure it with html.destination file(\"${buildDir}/reports/coverage\") . You can check the file build.gradle of this project.","title":"Own Gradle DSL"},{"location":"xgradle/#own-gradle-dsl","text":"","title":"Own Gradle DSL"},{"location":"xgradle/#purpose","text":"builder concept (chaining of tasks) standardization (junit, jacoco, ...)","title":"Purpose"},{"location":"xgradle/#build","text":"The xgradle DSL does use internally a Gradle class chaining the tasks clean and check : xgradle.build() Please note : In a declarative pipeline you have to place it in a script { ... } block.","title":"Build"},{"location":"xgradle/#publish","text":"Publishing of build results (junit, jacoco, HTML coverage and Pit test coverage): xgradle.publish() Please note : - In a declarative pipeline you have to place it in a script { ... } block. - The reports are published only when the path do exist; for coverage build/reports/coverage and for pit test build/reports/pitest are the expected paths. Using Jacoco you can configure it with html.destination file(\"${buildDir}/reports/coverage\") . You can check the file build.gradle of this project.","title":"Publish"},{"location":"xpublish/","text":"The publisher Publishing HTML Reports xpublish.html('HTML Code Coverage', 'build/reports/coverage') Please note : Using a declarative pipeline you have to call it inside a script { ... } block.","title":"The publisher"},{"location":"xpublish/#the-publisher","text":"","title":"The publisher"},{"location":"xpublish/#publishing-html-reports","text":"xpublish.html('HTML Code Coverage', 'build/reports/coverage') Please note : Using a declarative pipeline you have to call it inside a script { ... } block.","title":"Publishing HTML Reports"}]}