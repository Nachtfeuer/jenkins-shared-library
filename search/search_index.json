{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to the Jenkins shared library project Welcome to the Jenkins shared library project Purpose Quickstart About quality Useful links Purpose providing a reference example project for your own Jenkins shared library project demonstrating usage of the basic toolset: Groovy, Gradle, Jacoco, Codenarc, mkdocs, ... providing Jenkinsfile (declarative pipeline) as well as .travis.yml automatically running this project on Travis CI and publishing coverage on coveralls.io providing detailed documentation Quickstart Using the Gradle wrapper the configured Gradle version will be automatically downloaded and used. The basic requirements can be easily seen in the file Dockerfile serving as description for a Docker build image. ./gradlew About quality You should have a verified code style. The tool Codenarc provides you for Groovy what Checkstyle does for Java. The build does fail when any source code does not match the defined rules. It runs automatically with ./gradlew . Code coverage check is configured and 100% code coverage (line) is expected ! If you add new functionality without a test the build will fail. It also runs automatically with ./gradlew . Provide reasonable documentation . Any documentation like this one is for you as well as for others. Please consider source code documentation as well as markdown based documentation to help to understand things. Useful links https://jenkins.io/doc/book/pipeline/syntax/ https://jenkins.io/doc/book/pipeline/syntax/#declarative-pipeline https://jenkins.io/doc/book/pipeline/docker/ https://jenkins.io/doc/pipeline/steps/ https://gradle.org/ https://docs.gradle.org/current/userguide/jacoco_plugin.html https://gradle-pitest-plugin.solidsoft.info/ http://pitest.org/ http://codenarc.sourceforge.net/ https://www.mkdocs.org/","title":"Home"},{"location":"documentation/","text":"How to organize Documenation Markdown Markdown seems a good choice when writing documentation with just a small set of formatting capabilities reducing the documentation to what is really needed: titles sections bold and italic emphasizing code blocks tables links embedded images Mkdocs There are many good tools but I feel very comfortable with mkdocs because of following reasons: Easy to install ( sudo pip install mkdocs ) Easy to configure (Small and simple mkdocs.yml in the root of your repository) Easy to verify of the final result ( mkdocs serve ) Each change of the configured markdown files updates automatically your browser Easy to publish to github pages ( mkdocs gh-deploy ) In my case: simply my user and password for my Github account Please note: There's also a plugin for gradle but it looks to me that the excepted folder struture is different and I have not yet found a way to use the exising folder structure.","title":"How to organize Documenation"},{"location":"documentation/#how-to-organize-documenation","text":"","title":"How to organize Documenation"},{"location":"documentation/#markdown","text":"Markdown seems a good choice when writing documentation with just a small set of formatting capabilities reducing the documentation to what is really needed: titles sections bold and italic emphasizing code blocks tables links embedded images","title":"Markdown"},{"location":"documentation/#mkdocs","text":"There are many good tools but I feel very comfortable with mkdocs because of following reasons: Easy to install ( sudo pip install mkdocs ) Easy to configure (Small and simple mkdocs.yml in the root of your repository) Easy to verify of the final result ( mkdocs serve ) Each change of the configured markdown files updates automatically your browser Easy to publish to github pages ( mkdocs gh-deploy ) In my case: simply my user and password for my Github account Please note: There's also a plugin for gradle but it looks to me that the excepted folder struture is different and I have not yet found a way to use the exising folder structure.","title":"Mkdocs"},{"location":"gradle/","text":"How to organize Gradle How to organize Gradle Why Gradle? The Gradle Wrapper Current Gradle version Adding a wrapper Upgrading the Gradle version Basic Setup Best Practises Why Gradle? Gradle is very comfortable task manager to build your project. You can define the required tasks with a short amount of code . The Gradle Wrapper The gradle wrapper helps you to install the Gradle version you need. Current Gradle version ./gradlew --version Adding a wrapper gradle wrapper Upgrading the Gradle version Define the version of Gradle you would like to have: ./gradlew wrapper --gradle-version 4.9 You can verify it like following: $ cat gradle/wrapper/gradle-wrapper.properties distributionBase=GRADLE_USER_HOME distributionPath=wrapper/dists distributionUrl=https\\://services.gradle.org/distributions/gradle-4.9-bin.zip zipStoreBase=GRADLE_USER_HOME zipStorePath=wrapper/dists Basic Setup Of course it requires apply plugin: 'groovy' because the shared library (Jenkins) depends on it. The source sets have to be changed because the Jenkins guys do not use the standard folder structure as proposed by Maven/Gradle. The name of the languages (here: groovy) has been removed from the paths. You are not advised to use vars in the source sets because you cannot test the code and you code coverage would essentially decrease. Jacoco is used as official documented. Here 1.0 is adjusted as code coverage limit means 100% code coverage is expected. Adding new functionality without adding sufficient tests will fail the build. Codenarc is the static code analyser for Groovy. Most rules are used and located under config/codenarc/codenarc.rules . Every rule that is not correct applied will fail the build. Coveralls (a great service for visualizing code coverage results) is useful if you run your Github project with integrations like Travis CI - In both cases you have to enable the repository there before you can use it; in my case login with my Github Account to Travis CI as well as to COVERALLS ; it's mainly a button to toggle the wanted repository on/off. Best Practises When one of your tests is failing Gradle usually prints the path to the XML file instead of showing the problem. Therefor you can do following: gradle test -i ; the -i forces to print all to stdout and that way you can easily scroll back the terminal to the printed callstack. Continous testing can be done with gradle test -it . Gradle detects changes in files when you save them and reruns the tasks (here: all tests). You also can run individual tests with a filter: gradle test -it --tests GradleTest","title":"How to organize Gradle"},{"location":"virtualenv/","text":"Python virtual environments Python virtual environments Most simple usage Passing requirements Defining another virtual environment folder Error handling Most simple usage virtualenv { sh(script:'python -m install spline') sh(script:'python -m spline.application --help') } Passing requirements virtualenv(['spline', 'requests==2.12.4']) { sh(script:'python -m spline.application --help') } Defining another virtual environment folder virtualenv(['spline', 'requests==2.12.4'], 'another-venv') { sh(script:'python -m spline.application --help') } Error handling When inside a virtual environment an exception is thrown: the result of such a block is null . the pipeline state (currentBuild.result) will be set to 'FAILURE'. the virtual environment will be removed independent of that issue.","title":"Python virtual environments"},{"location":"xgradle/","text":"Own Gradle DSL Purpose builder concept (chaining of tasks) standardization (junit, jacoco, ...) Build The xgradle DSL does use internally a Gradle class chaining the tasks clean and check : xgradle.build() Please note : In a declarative pipeline you have to place it in a script { ... } . Publish Publishing of build results (junit, jacoco, ...): xgradle.publish() Please note : In a declarative pipeline you have to place it in a script { ... } .","title":"Own Gradle DSL"},{"location":"xgradle/#own-gradle-dsl","text":"","title":"Own Gradle DSL"},{"location":"xgradle/#purpose","text":"builder concept (chaining of tasks) standardization (junit, jacoco, ...)","title":"Purpose"},{"location":"xgradle/#build","text":"The xgradle DSL does use internally a Gradle class chaining the tasks clean and check : xgradle.build() Please note : In a declarative pipeline you have to place it in a script { ... } .","title":"Build"},{"location":"xgradle/#publish","text":"Publishing of build results (junit, jacoco, ...): xgradle.publish() Please note : In a declarative pipeline you have to place it in a script { ... } .","title":"Publish"}]}